  avg_method: 'median'  # how to average ensemble's L(t) at some t; "mean" averages, "median" finds median






def run_ensemble(n_runs, average_type, p1_conc, size, cce_params, time_space, cce_types, **kwargs):
    """
    Runs many simulations each with a unique bath configuration. A glorified for loop of the function run_sim.
    :param n_runs: number of unique baths generated
    :param average_type: how to average ensemble's L(t) at some t; "mean" averages, "median" finds median
    :param p1_conc: P1 concentration
    :param size: length in Angstroms of one side of the supercell
    :param cce_params: dictionary of Simulator params
    :param time_space: the numpy time space for the simulation run
    :param cce_types: 'conv' for conventional, 'gen' for generalized, 'MC' for generalized with MC bath
    :param kwargs: additional parameters
    :return: An np array with 3 columns. First is conv, second is gen, third is MC. The number of rows is time_space.
    Each element in the array is L(t) from 0 to 1, and has been averaged according to average_type over the n_runs runs.
    """
    first = kwargs.pop("verbose_once", False)  # if true, verbose for the first run in the ensemble

    results = []

    for i in range(n_runs):
        seed = np.random.randint(0, 2 ** 32, dtype='uint32')  # new seed each loop
        sim_kwargs = dict(kwargs)  # shallow copy so we can tweak per-run
        sim_kwargs["seed"] = seed
        sim_kwargs["verbose"] = first

        simulator = get_simulator(p1_conc, size, cce_params, **sim_kwargs)
        coherence = run_sim(simulator, cce_params, time_space, cce_types)
        results.append(coherence)

        first = False

    final = None
    if average_type == "median":
        final = np.median(np.stack(results, axis=0), axis=0)
    if average_type == "mean":
        final = np.stack(results, axis=0).mean(axis=0)

    return final





import numpy as np
import pycce as pc
from ase.build import bulk

# Bath spin types
#              name    spin    gyro       quadrupole (for s>1/2)
# ZFS parameters of NV center in diamond
SPIN_TYPES = [('14N',  1,      1.9338,    20.44),
              ('13C',  1 / 2,  6.72828         ),
              ('e'  ,  1 / 2,  -17608.5962784  )
             ]
D = 2.88 * 1e6 # kHz
E = 0 # kHz
UNIVERSAL_SEED = 8805


def p1_hyperfine(atoms, on):
    """
    Takes a BathCell with colocated P1 nuclei and electrons and returns either the hyperfine tensor or the zero matrix
    as a Pycce InteractionMap.
    :param atoms: the BathCell
    :param on: if True, returns the hyperfine tensor; otherwise returns zero matrix
    :return: an InteractionMap
    """
    e_idx = np.where(atoms.N == 'e')[0]  # get indices
    p1_idx = np.where(atoms.N == '14N')[0]
    assert np.array_equal(atoms[e_idx].xyz, atoms[p1_idx].xyz ) # ensure nuclei and electrons are colocated
    pairs = list(zip(e_idx, p1_idx))  # pair them up

    if on:
        # hyperfine tensor, from pg 17780 of https://pubs.acs.org/doi/pdf/10.1021/acs.jpcc.2c06145?ref=article_openPDF
        e_p1_interaction = [
            [82.0 * 1e3, 0, 0],
            [0, 82.0 * 1e3, 0],
            [0, 0, 114.0 * 1e3]
        ]
    else:  # in this case, the P1 HF is not considered
        e_p1_interaction = [[0, 0, 0],
                 [0, 0, 0],
                 [0, 0, 0]]

    imap = pc.InteractionMap()
    for i, j in pairs:
        imap[i, j] = e_p1_interaction  # J_ij between bath spins i and j
    return imap


def append_many(atoms, ids, label):
    """
    Add a spin into a BathCell for every existing spin with index in some list of indices. The new spins are at the same
    locations as the existing spins.
    :param atoms: the BathCell
    :param ids: the list of indices of existing spins
    :param label: the label of the new spin; e.g., "e"
    :return: a new BathCell with the added spins
    """
    ids = np.asarray(ids, dtype=int)
    add = np.zeros(len(ids), dtype=atoms.dtype)
    add['N'] = label
    add['xyz'] = atoms['xyz'][ids]
    return atoms.__class__(array=np.concatenate([atoms.view(np.ndarray),
                                                 add.view(np.ndarray)]))


def get_simulator(p1_conc, size, cce_params, **kwargs):
    """
    Builds unit cell, generates supercell, and returns a PyCCE Simulator with that supercell. The sueprcell is initially
    generated with 14C's, which utilizes Pycce's native isotopic substitution protocols. These 14Cs are then replaced
    with P1 nuclei and electrons. Note that the P1 nuclei and electrons have identical locations
    :param p1_conc: the p1 concentration in the supercell
    :param size: the length in Angstroms of one side of the supercell (approx.)
    :param cce_params: a dictionary of Simulator params
    :param kwargs: additional settings
    :return: a PyCCE Simulatoir object
    """
    p1_hf = kwargs.get("p1_hf", True)  # consider P1 e-nuclei hyperfine?
    seed = kwargs.get("seed", 8805)
    verbose = kwargs.get("verbose", False)  # prints out information
    gamma = kwargs.get("gamma", 0.0)  # polarization gamma. if 0, no polarization.
    zdir = kwargs.get("zdir", [1, 1, 1])  # z direction of the NV defect
    c13_conc = kwargs.get("c13_conc", 0.011)  # concentration of carbon 13
    debug_hf = kwargs.get("debug_hf", False)  # used to turn off custom P1 HF imap for debugging

    # build unit cell
    diamond = pc.read_ase(bulk('C', 'diamond', cubic=True))
    diamond.add_isotopes(('13C', c13_conc))
    diamond.add_isotopes(('14C', p1_conc))  # these are replaced with P1s later
    diamond.zdir = zdir  # set z direction of the defect

    # generate supercell
    atoms = diamond.gen_supercell(size,
                                  remove=[('C', [0., 0, 0]),  # remove NV carbons IF they are there
                                          ('C', [0.5, 0.5, 0.5])],
                                  add=[('14N', [0.5, 0.5, 0.5]), ],  # add NV nitrogen (e- added later)
                                  seed=seed)
    atoms.add_type(*SPIN_TYPES)
    assert np.allclose(atoms.A, atoms.A.flat[0])  # check that no hyperfine or quadrupoles have been added
    assert np.allclose(atoms.Q, atoms.Q.flat[0])

    # add in P1 nuclei and electrons
    mask = (atoms.N == '14C')
    idx = np.where(mask)[0]
    atoms = append_many(atoms, idx, 'e')  # add in electrons where 14Cs are
    idx_14n = np.where(atoms.N == '14N')[0]
    atoms = append_many(atoms, idx_14n, 'e')  # add in electron where NV nitrogen is
    atoms['N'][idx] = '14N'  # add in P1's by replacing the 14Cs with 14Ns

    if verbose:
        print("\nBUILT SUPERCELL:")
        print("# of atoms: ", len(atoms))
        print("# of 13C: ", len(atoms) - 2 * len(idx))
        print("# of P1s: ", len(idx))
        print("atoms: ", atoms)
    # build simulator
    nv = pc.CenterArray(spin=1, position=cce_params["position"], D=D, E=E,  # NV center
                        alpha=cce_params["alpha"], beta=cce_params["beta"])
    imap = p1_hyperfine(atoms, p1_hf)  # get imap for P1 electron-nuclei hyperfine
    calc = pc.Simulator(bath=atoms, spin=nv, imap=imap, **cce_params)
    if debug_hf:
        # calc = pc.Simulator(bath=atoms, spin=nv, hyperfine='pd', imap=imap, **cce_params)
        calc = pc.Simulator(bath=atoms, spin=nv, **cce_params)
    if verbose:
        print("\n\nBUILT SIMULATOR")
        print(calc)
    # if gamma is nonzero, will polarize the 13Cs in the Simulator's bath
    if gamma != 0:
        polos = np.exp(-(calc.bath.dist() / gamma) ** 2) * 0.5

        for a, pol in zip(calc.bath, polos):
            if a.N != '13C':
                continue  # Skip 14N and electrons
            # Generate density matrix
            dm = np.zeros((2, 2), dtype=np.complex128)
            dm[0, 0] = 0.5 + pol
            dm[1, 1] = 0.5 - pol
            a.state = dm

    return calc


def run_sim(calc, cce_params, time_space, cce_types, **kwargs):
    """
    Given a PyCCE Simulator object 'calc', runs simulations of the types in 'cce_types'
    :param calc: the PyCCE Simulator object to run the simulations with
    :param cce_params: a dictionary of Simulator params
    :param time_space: the numpy time space for the simulation run
    :param cce_types: 'conv' for conventional, 'gen' for generalized, 'MC' for generalized with MC bath
    :param kwargs: additional parameters
    :return: An np array with 3 columns. First is conv, second is gen, third is MC. The number of rows is time_space.
    Each element in the array is L(t) from 0 to 1.
    """
    n_pulses = kwargs.get("n_pulses", 1)  # number of pulses in CPMG seq (0 = FID, 1 = HE)
    pulse_sequence = kwargs.get("pulse_sequence", [pc.Pulse('x', np.pi)])  # Hahn-echo pulse sequence
    n_bath_states = kwargs.get("n_bath_states", 20)

    # initialize the array to be returned
    result = np.zeros((len(time_space), 3), dtype=float)

    # run the simulations for the various CCE types
    if 'conv' in cce_types:
        l_conv = calc.compute(time_space, pulses=n_pulses, magnetic_field=cce_params['magnetic_field'], method='cce',
                              quantity='coherence', as_delay=False)
        result[:, 0] = np.real(l_conv)
    if 'gen' in cce_types:
        l_generatilze = calc.compute(time_space, magnetic_field=cce_params['magnetic_field'],
                                     pulses=pulse_sequence, method='gcce', quantity='coherence')
        result[:, 1] = np.real(l_generatilze)
    if 'MC' in cce_types:
        # generalized CCE with random sampling of bath states
        l_gcce = calc.compute(time_space, magnetic_field=cce_params['magnetic_field'], pulses=pulse_sequence,
                              nbstates=n_bath_states, method='gcce',
                              quantity='coherence', seed=UNIVERSAL_SEED)
        result[:, 2] = np.real(l_gcce)

    return result


def run_ensemble(model_params, sim_params, ensemble_params):
    """
    Runs many simulations each with a unique bath configuration. A glorified for loop of the function run_sim.
    :param n_runs: number of unique baths generated
    :param average_type: how to average ensemble's L(t) at some t; "mean" averages, "median" finds median
    :param p1_conc: P1 concentration
    :param size: length in Angstroms of one side of the supercell
    :param cce_params: dictionary of Simulator params
    :param time_space: the numpy time space for the simulation run
    :param cce_types: 'conv' for conventional, 'gen' for generalized, 'MC' for generalized with MC bath
    :param kwargs: additional parameters
    :return: An np array with 3 columns. First is conv, second is gen, third is MC. The number of rows is time_space.
    Each element in the array is L(t) from 0 to 1, and has been averaged according to average_type over the n_runs runs.
    """

    n_runs = ensemble_params['n_runs']
    average_type = ensemble_params['average_type']

    results = []

    for i in range(n_runs):
        seed = np.random.randint(0, 2 ** 32, dtype='uint32')  # new seed each loop

        simulator = get_simulator(**sim_params)
        coherence = run_sim(simulator, cce_params, time_space, cce_types)
        results.append(coherence)

        verbose_once = False

    final = None
    if average_type == "median":
        final = np.median(np.stack(results, axis=0), axis=0)
    if average_type == "mean":
        final = np.stack(results, axis=0).mean(axis=0)

    return final
