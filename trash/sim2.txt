from model import run_ensemble
import numpy as np
import yaml
from pathlib import Path
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import time


# +++++++++++++++++++++++ Auxiliary functions +++++++++++++++++++++++ #
def make_output_dir(run_id: str, base: str = "output"):
    """
    Make output directory for a run: ./output/<run_id>/
    :param run_id: the run id from the config file
    :param base: the base output directory, should be ./output/
    :return: the output directory path as a string
    """
    base_path = Path(base)
    if not base_path.is_dir():
        raise RuntimeError(f"Base output directory '{base_path}' does not exist.")

    run_path = base_path / run_id
    try:
        run_path.mkdir()  # error if already exists
    except FileExistsError:
        raise RuntimeError(
            f"Run directory '{run_path}' already exists. "
            "Choose a new run_id or delete/rename the existing folder."
        )
    return str(run_path)


def load_config(path):
    """
    Loads the configuration from a YAML file.
    :param path: string path of the yaml file
    :return: the configuration as a dictionary
    """
    with open(path) as file:
        cfg = yaml.safe_load(file)

    # fix any non-Pythonic yaml variables
    time_space = cfg["compute_params"].pop("time_space")
    cfg["compute_params"]["time_space"] = np.linspace(time_space[0], time_space[1], time_space[2])

    # add run_id to every set of parameters
    cfg["model_params"]["run_id"] = cfg["run_id"]
    cfg["simulator_params"]["run_id"] = cfg["run_id"]
    cfg["compute_params"]["run_id"] = cfg["run_id"]
    cfg["ensemble_params"]["run_id"] = cfg["run_id"]

    return cfg


def average_ensemble(results, avg_method):
    """
    Expects a dictionary of length 3 of 2D arrays each with shape (num time_steps, ensemble_size), as is the output from
    the function model.run_ensemble. This will average over the ensemble using the method identified. For now there is
    just a simple mean and median.
    :param results: the output of model.run_ensemble
    :param avg_method: a string identifying the averaging method, straight from the yaml config file
    :return:
    """
    if avg_method == "mean":
        averaged = np.column_stack([np.mean(results[k], axis=-1) if results[k] is not None
                            else np.zeros(next(v for v in results.values() if v is not None).shape[0])  # num time_steps
                            for k in ("conv", "gen", "MC")])
    elif avg_method == "median":
        averaged = np.column_stack([np.median(results[k], axis=-1) if results[k] is not None
                            else np.zeros(next(v for v in results.values() if v is not None).shape[0])  # num time_steps
                            for k in ("conv", "gen", "MC")])
    else:
        raise Exception(f"Unknown averaging method")

    return averaged


def fit_curve_basic(results, time_space, cce_type="conv"):
    """
    Fit coherence L(t) to the stretched exponential exp(-(t/T2)^p).
    :param results: L(t)
    :param time_space: a numpy time space lining up with results
    :return: T2 (ms) and p.
    """
    # initial guess and bounds
    p0 = (0.1, 1.5)
    bounds = ([1e-6, 0.5], [1e6, 3.0])

    def stretch(t, T2, p):
        return np.exp(- (t / T2) ** p)

    if cce_type == "conv":
        idx = 0
    elif cce_type == "gen":
        idx = 1
    elif cce_type == "MC":
        idx = 2
    else:
        raise Exception(f"Unknown cce type")

    y = results.T[idx]  # CCE coherence
    T2, p = curve_fit(stretch, time_space, y, p0=p0, bounds=bounds)[0]
    return T2, p


def plot_coherence_panel(ax, time_space, result, cce_types, title=None, T2=None, p=None, runtime=None, config=None):
    """
    Draw a single coherence plot on the given axes.
    :param ax: axes to plot on
    :param time_space: numpy time space lining up with results
    :param result: numpy array with 3 columns, each being L(t) calculated with a different CCE method
    :param cce_types: the CCE methods used
    :param title: title of plot
    :param T2: T2 of the fitted curve
    :param p: p of the fitted curve
    :param runtime: how long it took to run
    :param config: config file, in case want to print more info on the plots
    :return: nothing
    """
    # plot each CCE curve
    for i, cce_type in enumerate(cce_types):
        ax.plot(time_space, result[:, i], label=cce_type)

    ax.set_xlabel("Time (ms)")
    ax.set_ylabel("Coherence")

    if title:
        ax.set_title(title)

    text_lines = []
    if config is not None:
        text_lines.append(f"size = {config['model_params']['size']}, p1_conc = {config['model_params']['p1_conc']}")
        text_lines.append(f"order = {config['simulator_params']['order']}, r_bath = "
                        f"{config['simulator_params']['r_bath']}, r_dipole = {config['simulator_params']['r_dipole']}")
        text_lines.append(f"ensemble = {config['ensemble_params']['ensemble_size']}, magnetic field = "
                          f"{config['compute_params']['magnetic_field']}")
    if T2 is not None:
        text_lines.append(f"Conventional " + r"$\mathbf{T2}$" + f"= {T2:.3g} ms")
    if p is not None:
        text_lines.append(f"Conventional " + r"$\mathbf{p}$" + f"= {p:.3g}")
    if runtime is not None:
        text_lines.append(r"$\mathbf{runtime}$" +  f"= {runtime:.2f} s")
    if text_lines:
        ax.text(0.99, 0.85, "\n".join(text_lines), transform=ax.transAxes, va="top", ha="right", fontsize=12)
    ax.legend()


# +++++++++++++++++++++++ Primary functions +++++++++++++++++++++++ #
def grid_search(base_config, param1, param2, param1_values, param2_values):
    """

    :param base_config:
    :param param1:
    :param param2:
    :param param1_values:
    :param param2_values:
    :return:
    """
    return None


def run_coherence_experiment(config):
    """

    :param config:
    :return:
    """
    run_id = config.pop("run_id")
    run_dir = make_output_dir(run_id)  # string path

    # create output text file
    out_dir = Path(run_dir)
    out_file = out_dir / (run_id + ".txt")
    with out_file.open("x", encoding="utf-8") as f:  # "x" = create, fail if exists
        f.write("Initialized output text file.\n")
        f.write(f"\nConfig:{config}.\n")

    # run experiment
    t_start = time.time()
    results = run_ensemble(**config)
    runtime = time.time() - t_start  # seconds

    # results is a dictionary; each value is an array with shape (time_steps, ensemble_size)
    avg_results = average_ensemble(results, avg_method=config["ensemble_params"]["avg_method"])

    # fit the curve and write to output
    T2, p = fit_curve_basic(avg_results, config["compute_params"]["time_space"], cce_type="conv")
    with out_file.open("a", encoding="utf-8") as f:
        f.write("\nResults:\n")
        f.write(f"\nRuntime:{runtime} s\n")
        f.write(f"\nConventional T2, p: {T2}, {p}\n")
        if "gen" in config["compute_params"]["cce_types"]:
            T2_gen, p_gen = fit_curve_basic(avg_results, config["compute_params"]["time_space"], cce_type="gen")
            f.write(f"\nGeneralized T2, p: {T2_gen}, {p_gen}\n")
        if "MC" in config["compute_params"]["cce_types"]:
            T2_mc, p_mc = fit_curve_basic(avg_results, config["compute_params"]["time_space"], cce_type="MC")
            f.write(f"\nGeneralized with MC T2, p: {T2_mc}, {p_mc}\n")

    # plot the results
    fig, ax = plt.subplots(figsize=(12, 8))
    plot_coherence_panel(ax, time_space=config["compute_params"]["time_space"], result=avg_results, config=config,
                         cce_types=config["compute_params"]["cce_types"], title=run_id, T2=T2, p=p, runtime=runtime)
    fig.tight_layout()
    fig.savefig(out_dir / f"{run_id}-plot.png", dpi=300)
    plt.close(fig)


def main(config_path, run_type_id):
    config = load_config(config_path)
    if run_type_id == "standard":
        run_coherence_experiment(config)
    elif run_type_id == "grid":
        grid_search(config, *config["model_params"]["params"])
    else:
        raise RuntimeError(f"Unknown run type '{run_type_id}'")


if __name__ == '__main__':
    yaml_path = "../config/3.dec.2025_ensemble-mean.yaml"
    run_type = "standard"  # "standard" or "grid"
    main(yaml_path, run_type)
